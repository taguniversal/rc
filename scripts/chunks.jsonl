{"id": "chunk_0", "text": "+++\ndate = '2025-03-15T20:23:59-05:00'\ndraft = false\ntitle = 'Ch12 THE INVOCATION LANGUAGE'\n+++", "metadata": {"source": "invocation_spec", "chunk_index": 0}}
{"id": "chunk_1", "text": "This chapter presents a symbol string language of direct association relationships that embodies the invocation model.", "metadata": {"source": "invocation_spec", "chunk_index": 1}}
{"id": "chunk_2", "text": "## 2.1 THE NATURE OF SYMBOL STRING EXPRESSION", "metadata": {"source": "invocation_spec", "chunk_index": 2}}
{"id": "chunk_3", "text": "The essential property of a symbol string is that it exists in an inherently limiting one-dimensional expression space. A symbol in the string can associate with its direct neighbors but cannot directly associate with more remote places in the string, Contrast this to the expression of an electronic circuit in three-dimensional space in which any place in the circuit can directly associate with any other place in the circuit via a wire connecting the two places.", "metadata": {"source": "invocation_spec", "chunk_index": 3}}
{"id": "chunk_4", "text": "A symbol string expression must be mappable to higher dimensional forms of expression. So there must be a means of expressing higher dimensional relationships in the one-dimensional string, a means of delimiting places within the string, and a means of associating these places from anywhere in the string to anywhere else in the string. This is accomplished with syntax structure and with name correspondence", "metadata": {"source": "invocation_spec", "chunk_index": 4}}
{"id": "chunk_5", "text": "Of the available symbols a small set is reserved for expressing syntax structures, and the rest can be used for expressing correspondence names and the content that flows through the expression. Syntax structure can express delimitation of places and their local association in terms of nesting and contiguity, but it cannot associate one place in the expression with arbitrary place in the expression. This is accomplished with name correspondence association. Each syntax structure has a unique name. Remote syntax structures with identical names are associated by the correspondence of their names.", "metadata": {"source": "invocation_spec", "chunk_index": 5}}
{"id": "chunk_6", "text": "Another consequence of the one-dimensionality of the symbol string is that there is not enough dimensionality for a symbol string expression to autonomously resolve in the context of the string. A symbol string expression can be mapped into an expression with sufficient dimensionality, or it can be interpreted within an expression of sufficient dimensionality. However, a symbol string cannot spontaneously behave on its own merits A symbol string expression is a purely referential form of expression.", "metadata": {"source": "invocation_spec", "chunk_index": 6}}
{"id": "chunk_7", "text": "Since a symbol string is purely referential it can indulge in efficiencies that are not available to expressions that autonomously It can express just the necessary relationships of a process and defer as universal conventions many of the details of process behavior. The deferred expressivity can be added back in during mapping to autonomy or interpretation.", "metadata": {"source": "invocation_spec", "chunk_index": 7}}
{"id": "chunk_8", "text": "## 12.2 A LANGUAGE OF ASSOCIATION RELATIONSHIPS", "metadata": {"source": "invocation_spec", "chunk_index": 8}}
{"id": "chunk_9", "text": "The invocation language embodies the invocation model. It expresses association relationships among places in an expression in contrast to a sequence of operations on a state space. It expresses distributed concurrency in contrast to centralized sequentiality. It expresses locally autonomous behavior in contrast to centrally controlled behavior. It expresses distributed data maintenance in contrast to centralized data maintenance Expression in the language is uniform and consistent from primitive expressions such as logic functions or protein interactions through all levels of hierarchical composition.", "metadata": {"source": "invocation_spec", "chunk_index": 9}}
{"id": "chunk_10", "text": "There are several familiar notions of expressivity that the language does not include. There is no predefined set of symbols, no predefined set of primitive operators, no predefined data types or structures, and no predefined control operators. There is no concept of sequence or of any time referent No concept of explicit control. no concept of explicitly addressable memory, and no concept of state space.", "metadata": {"source": "invocation_spec", "chunk_index": 10}}
{"id": "chunk_11", "text": "Expressions in the invocation language can be mapped into any form of implementation from a fully distributed and concurrent pipeline structure to a contemporary sequential processor and onto any intermediate flavor of distributed processing such as multiple core sequential processors. DSPs and programmable gate arrays. Uncluttered with conventions and confusions the invocation language captures the elegant simplicity of expressing concurrent and distributed behavior encompassing all forms of process expression from mathematical computation to biological metabolism.", "metadata": {"source": "invocation_spec", "chunk_index": 11}}
{"id": "chunk_12", "text": "## 12.3 THE SYNTAX STRUCTURES", "metadata": {"source": "invocation_spec", "chunk_index": 12}}
{"id": "chunk_13", "text": "There are four syntax structures the source place, the destination place. the invocation. and the definition. A source place anywhere in the string is laterally associated by name correspondence to one or more destination places.Boundaries within the network are expressed with an invocation. One or more destination places are associated as an input boundary. and one or more source places are associated as an output boundary. The invocation boundaries laterally associate with other invocations and hierarchically associate by name correspondence to a definition that contains the expression between the input and output boundaries of the invocation.", "metadata": {"source": "invocation_spec", "chunk_index": 13}}
{"id": "chunk_14", "text": "### 12.3.1 Lateral Composition: Place-to-Place Association", "metadata": {"source": "invocation_spec", "chunk_index": 14}}
{"id": "chunk_15", "text": "Non-neighbor places in the string are associated by name correspondence between a source place and one or more destination places. Sourcename is the correspondence name of the source place and destinationname is the correspondence name of the destination place.", "metadata": {"source": "invocation_spec", "chunk_index": 15}}
{"id": "chunk_16", "text": "Source place: `sourcename<content>`", "metadata": {"source": "invocation_spec", "chunk_index": 16}}
{"id": "chunk_17", "text": "Destination place: $destinationname", "metadata": {"source": "invocation_spec", "chunk_index": 17}}
{"id": "chunk_18", "text": "A source place will associate with all destination places with an identical correspondence name. The behavior model is that the content of a source place flows to each destination place of the same name. In Figure 12.1a AGXST is the content of a source place named Abel. Source place Abel< > is associated with one destination place $Abel by name correspondence. The AGXST will flow from source Abel< > to destination place $Abel. Figure 12.1b shows a source place named Baker with a content NGRYU with a fan-out association by name correspondence to three destination places named Baker. The content. NGRYU. will flow to all three destination places.", "metadata": {"source": "invocation_spec", "chunk_index": 18}}
{"id": "chunk_19", "text": "A single correspondence name can span only one association There cannot be two source places of the same name.", "metadata": {"source": "invocation_spec", "chunk_index": 19}}
{"id": "chunk_20", "text": "Figure 12.2a illustrates the ambiguity of identically named source places.\n```\n{\n  \"source_place\": {\n    \"name\": \"Abel\",\n    \"content\": \"AGXST\"\n  }\n}", "metadata": {"source": "invocation_spec", "chunk_index": 20}}
{"id": "chunk_21", "text": "{\n  \"destination_place\": {\n    \"name\": \"Abel\"\n  }\n}\n```\n```goat\n       \u250c\u2500\u2500\u2500\u2500\u2510                                                            \n       \u2502    \u2502             $Abel                                          \n       \u25bc    \u2502                  Name correspondence association           \n      Abel<AGST>                Syntactic structure association  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n                                                                         \n                                                                         \na. One to one association                                                \n                                                                         \n                                                                         \n                                                                         \n   \u250c\u2500\u2500\u2500\u2500\u2500\u2510          $Baker         $Baker                                \n   \u25bc     \u2502                                                               \n Baker<NGRYU>                                                            \n                        $Baker                                           \n                                                                         \n  b. Fan-out association                                                 \n                                                                         \n                                                                         \n                                                                         \nFigure 12.1 Source to destination association expressions                              \n```", "metadata": {"source": "invocation_spec", "chunk_index": 21}}
{"id": "chunk_22", "text": "a One-to-one association", "metadata": {"source": "invocation_spec", "chunk_index": 22}}
{"id": "chunk_23", "text": "Name correspondence association", "metadata": {"source": "invocation_spec", "chunk_index": 23}}
{"id": "chunk_24", "text": "Syntactic structure association\n```\n{\n  \"field\": [\n    {\n      \"_comment\": \"a. One-to-one association\",\n      \"source_place\": {\n        \"name\": \"Abel\",\n        \"content\": \"AGXST\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"Baker\"\n      }\n    },\n    {\n      \"_comment\": \"b. Fan-out association\",\n      \"source_place\": {\n        \"name\": \"Baker\",\n        \"content\": \"NGRYU\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"Baker\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"Baker\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"Baker\"\n      }\n    }\n  ]\n}\n```\nFigure 12.1 Source to destination association expressions", "metadata": {"source": "invocation_spec", "chunk_index": 24}}
{"id": "chunk_25", "text": "```\n{\n  \"field\": [\n    {\n      \"_comment\": \"a. Ambiguous association\",\n      \"source_place\": {\n        \"name\": \"Abel\",\n        \"content\": \"AGXST\"\n      }\n    },\n    {\n      \"source_place\": {\n        \"name\": \"Abel\",\n        \"content\": \"AGXST\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"Abel\"\n      }\n    },\n    {\n      \"_comment\": \"b. Daisy-chain association\",\n      \"source_place\": {\n        \"name\": \"first\",\n        \"content\": \"FDZPO\"\n      }\n    },\n    {\n      \"source_place\": {\n        \"name\": \"second\",\n        \"content\": \"$first\"\n      }\n    },\n    {\n      \"source_place\": {\n        \"name\": \"third\",\n        \"content\": \"$second\"\n      }\n    },\n    {\n      \"destination_place\": {\n        \"name\": \"third\"\n      }\n    }\n  ]\n}\n```\n```goat\n     Name correspondence association                     \n     Syntactic structure association \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba            \n                                                         \n \u250c\u2500\u2500\u2500\u2500\u2500\u2510                                                 \n \u2502     \u2502           $Abel                                 \n \u2502     \u2502                                                 \n \u25bc     \u2502                         Abel<>                  \nAbel<AGST>                                               \n                                                         \n          (a) Ambiguious Association                     \n                                                         \n                                                         \n   \u250c\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \n   \u2502     \u2502              \u2502     \u2502              \u2502     \u2502     \n   \u25bc     \u2502              \u25bc     \u2502              \u25bc     \u2502     \n first<FZPO>         second<$first>        third<$second>\n```\nFigure 12.2 Daisy chaining associations", "metadata": {"source": "invocation_spec", "chunk_index": 25}}
{"id": "chunk_26", "text": "To extend a path of association. a destination place associates with a differently named source place by syntax association Figure 12.2b shows a source place first<> with a content FSZPO that is associated with destination $first by name correspondence association. Destination place $first is associated with source place second<> by syntax structure association. Source place second<> is associated with destination place $second by name correspondence association Destination place $second is associated with source place third<> by syntax structure association. Source place third<> is associated with destination place $third by name correspondence association The FSZPQ in source place first<> ultimately flows through the associations to destination place Sthird.", "metadata": {"source": "invocation_spec", "chunk_index": 26}}
{"id": "chunk_27", "text": "Different syntax structures are associated by name correspondence and different correspondence names are associated by syntax structure Extended paths of association are expressed by alternating name correspondence association and syntax structure association. weaving a tapestry of arbitrarily complex association relationships in a one-dimensional string of symbols.", "metadata": {"source": "invocation_spec", "chunk_index": 27}}
{"id": "chunk_28", "text": "### 12.3.2 Hierarchical Composition: The Invocation and Definition", "metadata": {"source": "invocation_spec", "chunk_index": 28}}
{"id": "chunk_29", "text": "The invocation and definition express the boundaries of both lateral and hierarchical composition.", "metadata": {"source": "invocation_spec", "chunk_index": 29}}
{"id": "chunk_30", "text": "The Invocation - The invocation associates destination places to form an input boundary and associates source places to form an output boundary. The behavior model is that the boundaries are completeness boundaries and that the invocation expresses completeness criterion behavior between its input and output boundaries When the content at the output boundary is complete the content presented to the input is complete. and the output is the correct resolution of the content presented to the input boundary. Invocation boundaries are the boundaries of the expression. They are composition boundaries, coordination boundaries, and partition boundaries.", "metadata": {"source": "invocation_spec", "chunk_index": 30}}
{"id": "chunk_31", "text": "An invocation is a named syntax structure of two parenthesized lists. Invocationname is the correspondence name of the invocation The destination list is the input boundary for the invocation. in which the content to be resolved is received and the source list is the output boundary for the invocation, through which the result content is distributed.", "metadata": {"source": "invocation_spec", "chunk_index": 31}}
{"id": "chunk_32", "text": "```goat\n                        Name correspondence association                \n                                                                       \n                           Syntax structure association   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba   \n                                                                       \n                                                                       \n.....place1<1>  ...place2<0> ...place3<1>  ....$placeA   ...$placeB    \n                                                                       \n                                                                       \n                                                                       \n                                                                       \n                 ProcX($place1$place2$place3)(placeA<> placeB<>)       \n                    \u2502              \u2502                  \u2502                \n                    \u2502              \u2502                  \u2502                \n                    \u25bc              \u25bc                  \u25bc                \n                   name    destination list      source list           \n                                                                       \n                          input completeness       output completeness \n                            boundary               boundary            \n                                                                       \n            Figure 12.3 The invocation syntax and external associations\n```\nProcX($place1$place2$place3)(placeA<>placeB<>)\n```\n{\n  \"invocation\": {\n    \"name\": \"ProcX\",\n    \"destination_list\": [\"place1\", \"place2\", \"place3\"],\n    \"source_list\": [\"placeA\", \"placeB\"]\n  }\n}\n```\nFigure 12.3 The invocation syntax and external associations", "metadata": {"source": "invocation_spec", "chunk_index": 32}}
{"id": "chunk_33", "text": "Invocation - invocationname(destination list)(source list)", "metadata": {"source": "invocation_spec", "chunk_index": 33}}
{"id": "chunk_34", "text": "Figure 12.3 shows the syntax structure of the invocation and its external association relationships. ProcX is the correspondence name of the invocation that associates with a definition of the same name.", "metadata": {"source": "invocation_spec", "chunk_index": 34}}
{"id": "chunk_35", "text": "### The Definition\nThe definition expresses the network of associations between the boundaries of the associated invocation. A definition is a named syntax structure delimited by brackets containing a source list delimited by parenthesis, a destination list delimited by parenthesis. a place of resolution terminated by a colon followed by a place of contained definitions Definitionname is the correspondence name of the definition. The source list is the input for the definition through which a formed name is received, and the destination list is the output for the definition through which the results are delivered The place of resolution is best understood as a bounded pure value expression that can contain association expressions.", "metadata": {"source": "invocation_spec", "chunk_index": 35}}
{"id": "chunk_36", "text": "definition - definitionname[(source list) (destination list) place of resolution : contained definitions]", "metadata": {"source": "invocation_spec", "chunk_index": 36}}
{"id": "chunk_37", "text": "A definition associates to an invocation by name correspondence The place of resolution contains the expression between the boundaries that resolves the presented input to an asserted output. The source list receives the input contents by correspondence of syntax structure from an invocation destination list and associates them to destination places in the resolving expression in the place of resolution. The resolving expression contains source places that associate to the output destination places. The destination list receives the results from the source places of the resolving expression and returns them by correspondence of syntax structure to the invocation source list.\n```\n{\n  \"field\": [\n    {\n      \"definition\": {\n        \"name\": \"ProcX\",\n        \"source_list\": [\n          \"A\",\n          \"B\",\n          \"C\"\n        ],\n        \"destination_list\": [\n          \"result1\",\n          \"result2\"\n        ],\n        \"place_of_resolution\": [\n          {\n            \"invocation\": {\n              \"name\": \"ProcX\",\n              \"destination_list\": [\n                \"A\",\n                \"B\",\n                \"C\"\n              ],\n              \"source_list\": [\n                \"result1\",\n                \"result2\"\n              ]\n            }\n          }\n        ],\n        \"contained_definitions\": []\n      }\n    }\n  ]\n}\n```", "metadata": {"source": "invocation_spec", "chunk_index": 37}}
{"id": "chunk_38", "text": "Resolving expression in place of resolution", "metadata": {"source": "invocation_spec", "chunk_index": 38}}
{"id": "chunk_39", "text": "Figure 12.4 shows the syntax structure of the definition and its internal association relationships ProcX is the correspondence name of the definition and associates with a invocation of the same name.", "metadata": {"source": "invocation_spec", "chunk_index": 39}}
{"id": "chunk_40", "text": "### 12.3.3 The Association of Invocation and Definition", "metadata": {"source": "invocation_spec", "chunk_index": 40}}
{"id": "chunk_41", "text": "An invocation associates by name correspondence to an identically named definition The lists of the invocation associate with the lists of the definition by syntactic structure The source list of the definition associates to the destination list of the invocation by order correspondence The destination list of the definition associates to the source list of the invocation by order correspondence. This might seem somewhat confusing at first, but the rationale is straightforward.", "metadata": {"source": "invocation_spec", "chunk_index": 41}}
{"id": "chunk_42", "text": "In Figure 12.5a the invocation ABC associates by name correspondence to definition ABC Destination places of the invocation destination list associate by order with the source places of the definition source list. Source places of the invocation source list associate by order with the destination places of the definition destination list. The destination list of the invocation is places to where contents flow to form the content to be resolved The source list of the definition is the places from which the content flows to the resolving expression. The destination list of the definition is the places to where the results of the resolving expression will flow. and the source list of the invocation is the places from which results will flow to their destinations", "metadata": {"source": "invocation_spec", "chunk_index": 42}}
{"id": "chunk_43", "text": "Figure 12.5b gives a graphic representation of the invocation-definition syntactic interface", "metadata": {"source": "invocation_spec", "chunk_index": 43}}
{"id": "chunk_44", "text": "The interface relationships can also be understood in terms of daisychaining. Figure 12.5c shows the invocation and definition lists with destination places merged into their associated source places showing the relationship of the invocation and definition boundaries in terms of syntactic daisychaining", "metadata": {"source": "invocation_spec", "chunk_index": 44}}
{"id": "chunk_45", "text": "Because its interface of association places with the external expression is purely syntactic, a definition forms an isolated correspondence name domain for source places and destination places. Internal names can be chosen without concern that there will be ambiguity with the external expression.", "metadata": {"source": "invocation_spec", "chunk_index": 45}}
{"id": "chunk_46", "text": "```goat                                                             \n                                                                         \nInvocation   ABC($place1 $place2 $place3)(PlaceA<> PlaceB<>)             \n                                                                         \n                                                                         \n                                                                         \nDefinition  ABC[A<> B<> C<>)($result1 $result2)                          \n                      place of resolution                                \n                     :                                                   \n                      constant definitions]                              \n                                                                         \n               a. Symbol string representation                           \n                                                                         \n                                                                         \n                 Destination List          Source List                   \n  Invocation   $place1  $place2 $place3     placeA<>  placeB<>           \n                  \u25bc        \u25bc      \u25bc            \u25bc         \u25bc               \n                  \u25b2        \u25b2      \u25b2            \u25b2         \u25b2               \n  Definition     A<>      B<>    C<>        $result1  $result2           \n                     Source List             Destination list            \n                                                                         \n              b. Graphic representation                                  \n                                                                         \n                                                                         \n  ABC[A<$place1> B<$place2> C<place3>)(placeA<$result1> placeB<$result2>)\n                                                                         \n              c. Merged string representation                            \n                                                                         \n                                                                         \n      Figure 12.5 The syntactic association of invocation to definition  \n```", "metadata": {"source": "invocation_spec", "chunk_index": 46}}
{"id": "chunk_47", "text": "```goat\n.                                                                   \n  ..                                                                \n                                                              \n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                                                               \u2502\n   \u2502 invocation   FULLADD(0,1,0)(<> CARRYOUT<>) ... $CARRYOUT      \u2502\n   \u2502                                                               \u2502\n   \u2502 definition   FULLADD[(X<>Y<>C<>)($SUM $CARRY)                 \u2502\n   \u2502                                                               \u2502\n   \u2502                                                               \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                    \n                 Figure 12.1 Unnamed source place in an invocation  \n```", "metadata": {"source": "invocation_spec", "chunk_index": 47}}
{"id": "chunk_48", "text": "Example 12.1 Unnamed source place in an invocation", "metadata": {"source": "invocation_spec", "chunk_index": 48}}
{"id": "chunk_49", "text": "### 12.3.4 Abbreviated Forms of the Invocation and Definition", "metadata": {"source": "invocation_spec", "chunk_index": 49}}
{"id": "chunk_50", "text": "The invocation and definition syntax structures can be abbreviated to express simpler association relationships and also to accommodate familiar forms of symbol string expression.", "metadata": {"source": "invocation_spec", "chunk_index": 50}}
{"id": "chunk_51", "text": "### Return a Content to Place of Invocation", "metadata": {"source": "invocation_spec", "chunk_index": 51}}
{"id": "chunk_52", "text": "An unnamed source place in the source place list of an invocation associates by implicit name correspondence to the place of the invocation and no other place. The invocation itself becomes the single destination place for the returned result. In Example 12.1 the first source place in the source list of the invocation is unnamed The destination place $SUM in the destination list of the definition associates to the unnamed source place. The content flowing through $SUM will associate to the unnamed source place and flow to the place of the invocation.", "metadata": {"source": "invocation_spec", "chunk_index": 52}}
{"id": "chunk_53", "text": "### Single Return to Place of Invocation \nIf an invocation receives a single result in its own place, there is no need of a source list. The corresponding definition can express the single return with the absence of a destination line and with the presence of a single unnamed source place in the place of resolution. An expression like Example 12.2 can be further abbreviated to the form of Example 12.3", "metadata": {"source": "invocation_spec", "chunk_index": 53}}
{"id": "chunk_54", "text": "```goat\n                                                            \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \n    \u2502 invocation       AND($A $B)(<>)                             \u2502  \n    \u2502                                                             \u2502  \n    \u2502                                                             \u2502  \n    \u2502 definition   AND[(X<> Y<> C<>)($R)                          \u2502  \n    \u2502                           R< expr>                          \u2502  \n    \u2502                           :                                 \u2502  \n    \u2502                           constant definitions]             \u2502  \n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \n                                                                     \n     Example 12.2  Expressing a seingle return to place of invocation", "metadata": {"source": "invocation_spec", "chunk_index": 54}}
{"id": "chunk_55", "text": "```", "metadata": {"source": "invocation_spec", "chunk_index": 55}}
{"id": "chunk_56", "text": "```goat\n.                                                              \n  ..                                                           \n                                                               \n                                                               \n                                                               \n                                                               \n                                                               \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                             \u2502\n\u2502   invocation       AND($A $B)                               \u2502\n\u2502                                                             \u2502\n\u2502   derfinition      AND[X<>< Y<>) <expr> :                    \n\u2502                                                             \u2502\n\u2502                                constant definitions]        \u2502\n\u2502                                                             \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    Example 12.3 Further abbreviated expression of a single    \n                 return to place of invocation                 \n```", "metadata": {"source": "invocation_spec", "chunk_index": 56}}
{"id": "chunk_57", "text": "```goat                                             \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                                              \u2502\n    \u2502  <OR(AND(NOT($X) $Y) AND ($X NOT($Y)))>      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                    \n        Example 12.4 Nested Invocations             \n```", "metadata": {"source": "invocation_spec", "chunk_index": 57}}
{"id": "chunk_58", "text": "This abbreviation supports the familiar expressional form of functional nesting. In Example 12.4 each invocation has only a destination list and is part of the destination list of another invocation or is within a source place.", "metadata": {"source": "invocation_spec", "chunk_index": 58}}
{"id": "chunk_59", "text": "### The Conditional Invocation Name \nIf an invocation has an empty destination list. i.e. no input. then the invocationname itself must express the variable part of the invocation The conditional invocationname is the mechanism of content transformation in the language. The invocation correspondence name is formed from the content of one or more contiguous destination places. Content emerges from flow paths to interact by forming the correspondence name of an invocation All content flowing through the association paths eventually emerges to form an invocation correspondence name. This is how value transform rules are invoked to transform the flowing content of the expression.", "metadata": {"source": "invocation_spec", "chunk_index": 59}}
{"id": "chunk_60", "text": "`SplacelSplace2Splace3()`", "metadata": {"source": "invocation_spec", "chunk_index": 60}}
{"id": "chunk_61", "text": "### The Constant Definition \nIf a definition does not contain a source list and does not contain a definition list. it is a constant definition With no input associations there is no content flow into the definition to resolve no need for internal definitions. and no need for the colon. A constant definition contains only a place of resolution between the brackets which contains a constant content and can be abbreviated as shown below:", "metadata": {"source": "invocation_spec", "chunk_index": 61}}
{"id": "chunk_62", "text": "`definitionname [constant]`", "metadata": {"source": "invocation_spec", "chunk_index": 62}}
{"id": "chunk_63", "text": "```goat\n                                                       \n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \n  \u2502                                                      \u2502   \n  \u2502 AND[(A<>B<>)<$A$B()> : 00[0] 01[0] 10[0] 11[1]]      \u2502   \n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \n                                                             \n Example 12.5 OR function with value transform rule definitions\n```", "metadata": {"source": "invocation_spec", "chunk_index": 63}}
{"id": "chunk_64", "text": "```goat    \n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                                      \u2502\n        \u2502     def fanout[(select<> in<>)({$out1 $out2})        \u2502\n        \u2502                                                      \u2502\n        \u2502         $select():  A[out1<$in>]                     \u2502\n        \u2502                     B[out2<$in>]]                    \u2502\n        \u2502                                                      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  Example 12.6 Fan-out steering                 \n```", "metadata": {"source": "invocation_spec", "chunk_index": 64}}
{"id": "chunk_65", "text": "Since there is no destination list, the constant content is returned to the place of invocation. A constant definition rule expresses a value transform rule. Example 12.5 shows the value transform definitions for the AND function. The content values 1 or 0 will p propagate that through A< > and B< >, and a two-value name will be formed by $A$B() that will invoke one of the contained definitions. The constant of the invoked definition will return to the place of the invocation, entering a flow path in the unnamed source place, and will flow through the unnamed source place back to the invocation of AND. The set of constant definisons-value transform rule definitions-expresses the truth table of the AND function. One can think of the content forming the invocationname that transforms into the content of the definition.", "metadata": {"source": "invocation_spec", "chunk_index": 65}}
{"id": "chunk_66", "text": "A constant definition can also contain a fragment of expression including an invocation that will be returned to the place of invocation. The formation of an invocationname in a place of resolution results in the fragment of expression in the corresponding constant definition being returned to the place of invocation in the place of resolution and consequently being resolved. In Example 12.6 the content of `select< >` will be A or B. This content flows to Seelect and forms the invocation A() or B(), invoking one of the two contained definitions. The content of the named definition is returned to the place of invocation in the place of resolution and resolved directing the input to one of two possible output association paths.", "metadata": {"source": "invocation_spec", "chunk_index": 66}}
{"id": "chunk_67", "text": "### The Pure Value Expression \nIf there are no list parenthesis in a place of resolution, then there are no explicit invocations. The contents flowing into a place of resolution are assumed to be freely associating values of a pure value expression that will form names of contained definitions. The contained definitions are value transform rules, or they contain association expression fragments to be inserted into the place of resolution.", "metadata": {"source": "invocation_spec", "chunk_index": 67}}
{"id": "chunk_68", "text": "`definitionname[(A<>B<>C<>)( ...) $A$B$C : ...]`", "metadata": {"source": "invocation_spec", "chunk_index": 68}}
{"id": "chunk_69", "text": "The place of resolution of Example 12.26, as seen later in this chapter, contains a pure value expression.", "metadata": {"source": "invocation_spec", "chunk_index": 69}}
