module NashTest where
import NashCore
import RandData

// Test vectors
test_input1 : [32]Bit
test_input1 = zero    // All zeros

test_input2 : [32]Bit
test_input2 = ~zero   // All ones

test_input3 : [32]Bit
test_input3 = [True] # [False] # (zero:[30])

test_input4 : [32]Bit
test_input4 = join [0xA5A5A5A5]

// Basic property tests
property test_transform_symmetry = \(t : Bit) (b : Bit) -> transform t (transform t b) == b
property test_valid_permutations = sort ([s.next_state | s <- red_perms]) == sort [0 .. 127]
property test_valid_permutations_blue = sort ([s.next_state | s <- blue_perms]) == sort [0 .. 127]

// Single bit cycle test with state validation
property single_bit_cycle (bit : Bit) = 
    bit == recovered /\ valid_state enc_state /\ valid_state dec_state where
        init_st = init_cipher zero
        (output, enc_state) = transmit red_perms blue_perms bit init_st
        (recovered, dec_state) = receive red_perms blue_perms output enc_state

// Full cycle test with validation
property full_cycle (input : [32]Bit) = 
    input == recovered /\ all valid_state enc_states /\ all valid_state dec_states where
        init_st = init_cipher (zero:[8])
        enc_states = [init_st] # [s | (_, s) <- enc_steps]
        enc_steps = [transmit red_perms blue_perms x s | x <- input | s <- enc_states]
        (encrypted, _) = cipher_sequence red_perms blue_perms input init_st
        dec_states = [init_st] # [s | (_, s) <- dec_steps]
        dec_steps = [receive red_perms blue_perms x s | x <- encrypted | s <- dec_states]
        (recovered, _) = decipher_sequence red_perms blue_perms encrypted init_st

// Test vectors
property full_cycle_1 = full_cycle test_input1
property full_cycle_2 = full_cycle test_input2
property full_cycle_3 = full_cycle test_input3
property full_cycle_4 = full_cycle test_input4

// Identity tests
property not_identity_1 = test_input1 != enc where
    (enc, _) = cipher_sequence red_perms blue_perms test_input1 (init_cipher (zero:[8]))

property not_identity_2 = test_input2 != enc where
    (enc, _) = cipher_sequence red_perms blue_perms test_input2 (init_cipher (zero:[8]))

property not_identity_3 = test_input3 != enc where
    (enc, _) = cipher_sequence red_perms blue_perms test_input3 (init_cipher (zero:[8]))

property not_identity_4 = test_input4 != enc where
    (enc, _) = cipher_sequence red_perms blue_perms test_input4 (init_cipher (zero:[8]))

// State validation
property all_states_valid input = 
    all valid_state (enc_states # dec_states) where
        init_st = init_cipher (zero:[8])
        enc_states = [init_st] # [s | (_, s) <- enc_steps]
        enc_steps = [transmit red_perms blue_perms x s | x <- input | s <- enc_states]
        (encrypted, _) = cipher_sequence red_perms blue_perms input init_st
        dec_states = [init_st] # [s | (_, s) <- dec_steps]
        dec_steps = [receive red_perms blue_perms x s | x <- encrypted | s <- dec_states]

// Permutation validation
property red_perms_valid = all (\p -> p.next_state < 128) red_perms
property blue_perms_valid = all (\p -> p.next_state < 128) blue_perms