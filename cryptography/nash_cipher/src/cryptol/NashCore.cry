module NashCore where

type State = [8]
type TransFunc = Bit

type Perm = {
    next_state : State,
    transform  : TransFunc
}

type CipherState = {
    curr_state : State,
    memory : [8]Bit,
    curr_input : Bit,
    prev_output : Bit
}

mask_state : State -> State
mask_state s = s && 127

init_cipher : [8]Bit -> CipherState
init_cipher initial_mem = {
    curr_state = 0,
    memory = initial_mem,
    curr_input = False,
    prev_output = False
}

transform : TransFunc -> Bit -> Bit
transform t b = if t then ~b else b

// Core permutation operation
permute : [128]Perm -> State -> Bit -> (State, Bit)
permute perms curr_state input = (next_s, perm_out) where
    curr_perm = perms @ (mask_state curr_state)
    next_s = mask_state curr_perm.next_state
    perm_out = transform curr_perm.transform input

// Transmit function (encryption)
transmit : [128]Perm -> [128]Perm -> Bit -> CipherState -> (Bit, CipherState)
transmit red_perm blue_perm input state = (cipher_bit, next_state) where
    // Select permutation based on current input
    curr_perms = if input then red_perm else blue_perm
    // Get permutation output
    (next_s, perm_out) = permute curr_perms state.curr_state input
    // Create cipher bit
    cipher_bit = input ^ perm_out
    // Update state for next round
    next_mem = [input] # (drop`{1} state.memory)
    next_state = {
        curr_state = next_s,
        memory = next_mem,
        curr_input = input,  // Remember current input
        prev_output = perm_out  // Store permutation output
    }

// Receive function (decryption)
receive : [128]Perm -> [128]Perm -> Bit -> CipherState -> (Bit, CipherState)
receive red_perm blue_perm cipher_bit state = (recovered_bit, next_state) where
    // First recover the original input using stored permutation output
    recovered_bit = cipher_bit ^ state.prev_output
    // Select permutation based on recovered bit
    curr_perms = if recovered_bit then red_perm else blue_perm
    // Get permutation output for next state
    (next_s, perm_out) = permute curr_perms state.curr_state cipher_bit
    // Update state for next round
    next_mem = [cipher_bit] # (drop`{1} state.memory)
    next_state = {
        curr_state = next_s,
        memory = next_mem,
        curr_input = recovered_bit,  // Store recovered bit for next round
        prev_output = perm_out  // Store new permutation output
    }

// Sequence encryption
cipher_sequence : {n} (fin n) => [128]Perm -> [128]Perm -> [n]Bit -> CipherState -> ([n]Bit, CipherState)
cipher_sequence red_perm blue_perm inputs init_state = (outputs, final_state) where
    states = [init_state] # [s | (_, s) <- steps]
    steps = [transmit red_perm blue_perm input state 
            | input <- inputs 
            | state <- states]
    outputs = [output | (output, _) <- steps]
    final_state = last states

// Sequence decryption with synchronized permutation selection
decipher_sequence : {n} (fin n) => [128]Perm -> [128]Perm -> [n]Bit -> CipherState -> ([n]Bit, CipherState)
decipher_sequence red_perm blue_perm inputs init_state = (outputs, final_state) where
    states = [init_state] # [state | (_, state) <- steps]
    steps = [receive red_perm blue_perm input state 
            | input <- inputs 
            | state <- states]
    outputs = [output | (output, _) <- steps]
    final_state = last states

// Properties
property valid_state = \(s : CipherState) -> mask_state s.curr_state == s.curr_state

property forms_cycle = \(perms : [128]Perm) (s : State) -> 
    s < `127 ==> 
    all (\x -> x < `127) (take`{128} (iterate (\y -> mask_state ((perms@(mask_state y)).next_state)) s))